-- A library to load maps generated by Tiled
-- Neil Holmes - 2016

local mapLoader = {}

-- Return the quad for a tileid
function getQuad(map, tileId)
  -- Get the x index of the tile
  tileX = (((tileId -1) % (map.tilesets[1].imagewidth/map.tilesets[1].tilewidth)) * map.tilesets[1].tilewidth)
  -- get the y index of the tile
  tileY = ((math.floor((tileId - 1) / (map.tilesets[1].imagewidth/map.tilesets[1].tilewidth))) * map.tilesets[1].tilewidth)
  return love.graphics.newQuad(tileX, tileY, map.tilesets[1].tilewidth, map.tilesets[1].tileheight, map.tilesets[1].imagewidth, map.tilesets[1].imageheight)
end -- getQuad()

-- fill a table with the tile quads in use
function getTiles(map)
  local ids = {} -- list of all tileIds
  local tileids = {} -- list of non-duplicate tileIds
  local tiles = {} -- table of quads for each tileId
  local hash = {} -- used for de-dup
  -- union all map data across layers
  local n = 1
  for i=1, table.getn(map.layers) do
    if map.layers[i].type == "tilelayer" then
      for v in pairs(map.layers[i].data) do
        ids[n] = map.layers[i].data[v]
        n = n+1
      end
    end
  end
  -- get unique tileIDs
  for _,v in ipairs(ids) do
    if (not hash[v]) then
      tileids[#tileids+1] = v
      hash[v] = true
    end
  end
  -- create the table containing the quads
  for i=1, table.getn(tileids) do
    r = tileids[i]
    tiles[r] = getQuad(map, r)
  end
  -- return the table of quads
  return tiles
end -- getTiles()

-- get objects from a named object layer
function getMapObjectLayer(map, collider, blockingLayerString)
  local collisionTileTable = {}
  local blockinglayer = nil
  local row = 1
  local column = 1

  for i=1, table.getn(map.file.layers) do
    if map.file.layers[i].name == blockingLayerString then
      -- find the blocking layer
      blockinglayer = i
    end
  end

  -- draw each blocking object
  for i=1, table.getn(map.file.layers[blockinglayer].objects) do
    if map.file.layers[blockinglayer].objects[i].shape == "rectangle" then
      table.insert(collisionTileTable, collider:rectangle(map.file.layers[blockinglayer].objects[i].x, map.file.layers[blockinglayer].objects[i].y,
          map.file.layers[blockinglayer].objects[i].width, map.file.layers[blockinglayer].objects[i].height))
      collisionTileTable[table.getn(collisionTileTable)].name = blockingLayerString
    elseif map.file.layers[blockinglayer].objects[i].shape == "ellipse" then
      table.insert(collisionTileTable, collider:circle(map.file.layers[blockinglayer].objects[i].x + (map.file.layers[blockinglayer].objects[i].width/2),
          map.file.layers[blockinglayer].objects[i].y + (map.file.layers[blockinglayer].objects[i].width/2),
          map.file.layers[blockinglayer].objects[i].width/2))
      collisionTileTable[table.getn(collisionTileTable)].name = blockingLayerString
    end
  end
  return collisionTileTable
end -- getMapObjectLayer()

function getScoreObjects(map, collider, scoreLayerString)
  local scoreObjectTable = {}
  local scoreLayer = nil
  for i=1, table.getn(map.file.layers) do
    if map.file.layers[i].name == scoreLayerString then
      -- find the blocking layer
      scoreLayer = i
    end
  end
  -- create each blocking object
  for i=1, table.getn(map.file.layers[scoreLayer].objects) do
    if map.file.layers[scoreLayer].objects[i].shape == "rectangle" then
      table.insert(scoreObjectTable, collider:rectangle(map.file.layers[scoreLayer].objects[i].x, map.file.layers[scoreLayer].objects[i].y,
          map.file.layers[scoreLayer].objects[i].width, map.file.layers[scoreLayer].objects[i].height))
      scoreObjectTable[table.getn(scoreObjectTable)].x = map.file.layers[scoreLayer].objects[i].x
      scoreObjectTable[table.getn(scoreObjectTable)].y = map.file.layers[scoreLayer].objects[i].y
      scoreObjectTable[table.getn(scoreObjectTable)].width = map.file.layers[scoreLayer].objects[i].width
      scoreObjectTable[table.getn(scoreObjectTable)].height = map.file.layers[scoreLayer].objects[i].height
      scoreObjectTable[table.getn(scoreObjectTable)].number = map.file.layers[scoreLayer].objects[i].name
    elseif map.file.layers[scoreLayer].objects[i].shape == "ellipse" then
      table.insert(scoreObjectTable, collider:circle(map.file.layers[scoreLayer].objects[i].x + (map.file.layers[scoreLayer].objects[i].width/2),
          map.file.layers[scoreLayer].objects[i].y + (map.file.layers[scoreLayer].objects[i].width/2),
          map.file.layers[scoreLayer].objects[i].width/2))
      scoreObjectTable[table.getn(scoreObjectTable)].x = map.file.layers[scoreLayer].objects[i].x
      scoreObjectTable[table.getn(scoreObjectTable)].y = map.file.layers[scoreLayer].objects[i].y
      scoreObjectTable[table.getn(scoreObjectTable)].width = map.file.layers[scoreLayer].objects[i].width
      scoreObjectTable[table.getn(scoreObjectTable)].height = map.file.layers[scoreLayer].objects[i].height
      scoreObjectTable[table.getn(scoreObjectTable)].number = map.file.layers[scoreLayer].objects[i].name
    end
  end
  -- sort the order of the array based on the object name (which is a string!)
  local sortFunc = function(a, b) return a.number < b.number end
  table.sort(scoreObjectTable, sortFunc)
  return scoreObjectTable
end -- getScoreTiles()

function drawMap(map, minLayer, maxLayer)
  -- iterate layers
  if table.getn(map.file.layers) < maxLayer then
    maxLayer = table.getn(map.file.layers)
  end
  if minLayer <= 0 then
    minLayer = 1
  end
  for n = minLayer, maxLayer do
    if map.file.layers[n].type == "tilelayer" then
        local row = 1
        local column = 1
        -- for each data elemnt in the layer's table
        for l = 1, table.getn(map.file.layers[n].data) do
          -- goto the next row if we've passed the screen width and reset columns
          if column > map.file.layers[n].width then
            column = 1
            row = row + 1
          end
          -- draw the tile as long as it's not 0 (empty)
          if map.file.layers[n].data[l] ~= 0 then
            love.graphics.setColor(256,256,256)
            love.graphics.draw(map.atlas, map.tiles[map.file.layers[n].data[l]],
              (column * map.file.tileheight) - map.file.tileheight, (row * map.file.tilewidth) - map.file.tilewidth)
          end
          -- move to the next column
          column = column + 1
        end
      end
    end
end -- drawMap()

function getPlayerStart(map)
  local coords = {}
  for i=1, table.getn(map.file.layers) do
    if map.file.layers[i].name == "playerstart" then
      coords.x = map.file.layers[i].objects[1].x
      coords.y = map.file.layers[i].objects[1].y
    end
  end
  return coords
end --getPlayerStart()

function loadMap(path, atlaspath)
  -- Creates a map table with the following values:
  --  .file - a handle to the lua map file
  --  .atlas - the image to use asthe tilemap
  --  .tiles - a table indexed for each tileid
  -- load the map file
  map.file = love.filesystem.load(path)()
  -- load the atlas
  -- TODO: make this load each atlas per layer
  map.atlas = love.graphics.newImage(atlaspath)
  -- load the tiles for the map
  map.tiles = getTiles(map.file)
  --return the map table
  return map
end --loadMap()

return mapLoader
